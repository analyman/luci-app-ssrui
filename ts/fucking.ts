/// <reference path="../www/luci-static/resources/ssrui/fucking.js"/>

import {SSRServer, SSRSubscription, default_local_address, default_local_port} from './subscribe';
import {UActiveChange, UContentChange, UServerListChange} from './event';
import * as utils from './utils';
import * as fucking from '../www/luci-static/resources/ssrui/fucking';

// these infomation of image should be generated by lua in html, in other words should be 
// accessable in global scope
let img_dir = (window as any).img_dir   || "/luci-static/resources/ssrui/img/";
let imgs    = (window as any).roll_imgs || ["cat.jpg"];


document.addEventListener("DOMContentLoaded", function() {
    fucking.retry_get_elements();

    fucking.ElementsAccessor.subscriptions_group.addEventListener(UContentChange, function() {
        let list: any[] = fucking.classify_servers_by_subscription(fucking.VarAccessor.server_index);
        let out: any[] = [];
        list.map(x => out.push([x.group, x.server_list[0].group]));
        update_list_group(fucking.ElementsAccessor.subscriptions_group, out.map(x => x[1]), ["list-group-item"], "subscription", true, "NEW");
        for(let i = 0; i<fucking.ElementsAccessor.subscriptions_group.children.length - 1; i++)
            (fucking.ElementsAccessor.subscriptions_group.children[i] as any).ex_info = out[i][0] || "unknow address";
        (fucking.ElementsAccessor.subscriptions_group.lastChild as any).ex_info = "add new subscription";
        fucking.ElementsAccessor.links_group.dispatchEvent(new CustomEvent(UContentChange));
    });

    document.addEventListener(UServerListChange, function() {
        fucking.ElementsAccessor.subscriptions_group.dispatchEvent(new CustomEvent(UContentChange));
    });

    // mouse hover behavior
    fucking.ElementsAccessor.subscriptions_group.addEventListener("mouseover", function(earg: MouseEvent) {
        earg.stopPropagation();
        let origin_li: HTMLElement = earg.target as HTMLElement;
        if(origin_li.nodeName.toLowerCase() != "li") origin_li = (origin_li as HTMLElement).parentNode as HTMLElement;
        if(origin_li.nodeName.toLowerCase() != "li") return;
        let width:  number = origin_li.offsetWidth * 0.7;
        let height: number = origin_li.offsetHeight;
        let insert_tip: HTMLElement = utils.createNodeFromHtmlString(`<div class='rounded bg-white border border-warning m-2 p-2 position-absolute' style="z-index: 3; width: ${width}px;">` 
            + (origin_li as any).ex_info + "</div>");
        height += (insert_tip as HTMLElement).offsetHeight;
        insert_tip.style.bottom = (height * 1.05).toString();
        origin_li.appendChild(insert_tip);
        return;
    });
    fucking.ElementsAccessor.subscriptions_group.addEventListener("mouseout", function(earg: MouseEvent) {
        earg.stopPropagation();
        let origin_li: Element = earg.target as Element;
        if(origin_li.nodeName.toLowerCase() != "li") origin_li = (origin_li as Element).parentNode as Element;
        if(origin_li.nodeName.toLowerCase() != "li") return;
        origin_li.removeChild(origin_li.lastChild);
        return;
    });

    fucking.ElementsAccessor.links_group.addEventListener(UContentChange, function() {
        let i: number;
        let c_len = fucking.ElementsAccessor.subscriptions_group.children.length;
        for(i = 0; i<c_len; i++)
            if((fucking.ElementsAccessor.subscriptions_group.children[i].firstChild as HTMLElement).classList.contains("active"))
                break;
        let active_elem: HTMLElement = fucking.ElementsAccessor.subscriptions_group.children[i] as HTMLElement;
        if (i == c_len - 1) {
            while(fucking.ElementsAccessor.links_group.firstChild)
                fucking.ElementsAccessor.links_group.removeChild(fucking.ElementsAccessor.links_group.firstChild);
            let BG_IMG: HTMLElement = utils.createNodeFromHtmlString(`<li class="list-group-item hello"><div class="rounded"><img class="mw-100 mh-100 h-auto"></div></li>`);
            fucking.ElementsAccessor.links_group.appendChild(BG_IMG);
            img_roll_inject_css(BG_IMG.firstChild as HTMLElement, img_dir, imgs, 0, 3 * 1000);
            return;
        }
        let link: string = (active_elem as any).ex_info;
        let list: any[] = fucking.classify_servers_by_subscription(fucking.VarAccessor.server_index);
        let server_list: any[] = null;
        for(let j = 0; j<list.length; j++) {
            if(link == list[j].group){
                server_list = list[j].server_list;
                break;
            }
        }
        if(server_list == null) {
            console.error("asdfzxcv");
            return;
        }
        let out: any[] = [];
        server_list.map(x => out.push(x.remarks || "UNKONW"));
        update_list_group(fucking.ElementsAccessor.links_group, out, ["list-group-item"], "link", false);
        // TODO little info table about this server;
        for(let i = 0; i<fucking.ElementsAccessor.subscriptions_group.children.length - 1; i++)
            break;
    });

    // LIST CLICK Events
    fucking.ElementsAccessor.links_group.addEventListener("click", (ev: MouseEvent) => {
        list_click_change_active(ev);
    });
    fucking.ElementsAccessor.subscriptions_group.addEventListener("click", (ev: MouseEvent) => {
        let result = list_click_change_active(ev);
        if (result) 
            fucking.ElementsAccessor.links_group.dispatchEvent(new CustomEvent(UContentChange));
    });
});

// (ul | or) > li > a.active
export function list_click_change_active(eargs: Event): boolean //{
{
    let origin_target: Element  = eargs.target as Element;
    let current_target: Element = eargs.currentTarget as Element;
    if (!current_target.nodeName.toLowerCase().match(/(ul)|(ol)/)) return false;
    if (origin_target.nodeName.toLowerCase() != "a") return false;
    if (origin_target.parentNode.nodeName.toLowerCase() != "li") return false;
    if (origin_target.parentNode.parentNode != current_target) return false;
    eargs.stopPropagation();
    if (origin_target.classList.contains("active")) return false;
    for(let i = 0; i<current_target.children.length; ++i) {
        current_target.children[i].children[0].classList.remove("active");
    }
    origin_target.classList.add("active");
    return true;
} //}

export function update_list_group(
    list: Element, msgs: string[], extra_classes: string[], href_and_id_prefix: string,
    new_button: boolean = false, new_button_str: string = "NEW"): void //{
{
    if (!list.nodeName.toLowerCase().match(/(ol)|(ul)/)) return;
    let k: number = 0;
    for(let j = 0; j<list.children.length; ++j) {
        if (list.children[j].nodeName.toLowerCase() != "li")
            continue;
        if (list.children[j].children[0].classList.contains("active"))
            break;
        ++k;
    }
    while(list.lastChild)
        list.removeChild(list.lastChild);
    if (msgs.length == 0 && !new_button) return;
    let new_node_li = document.createElement("li");
    let new_node    = document.createElement("a");
    new_node_li.appendChild(new_node);
    for(let i = 0; i<msgs.length; ++i) {
        let nn: Element = new_node_li.cloneNode(true) as Element;
        nn.children[0].setAttribute("href", "#" + href_and_id_prefix + (i + 1));
        nn.children[0].setAttribute("id",   href_and_id_prefix + "-" + (i + 1));
        nn.children[0].innerHTML = msgs[i];
        extra_classes.map(cls => nn.children[0].classList.add(cls));
        list.appendChild(nn);
    }
    if (new_button) {
        new_node.setAttribute("href", "#" + href_and_id_prefix + "0");
        new_node.setAttribute("id",   href_and_id_prefix + "-" + "0");
        new_node.innerHTML = new_button_str;
        extra_classes.map(cls => new_node.classList.add(cls));
        list.appendChild(new_node_li);
    }
    if (list.children.length <= k)
        (list.lastChild.firstChild as Element).classList.add("active");
    else
        list.children[k].children[0].classList.add("active");
    return;
} //}

export function img_roll(img_elem: HTMLElement, dir: string, imgs: string[], where: number, interval: number): void //{
{
    if(utils.isHidden(img_elem)) return;
    if(where >= imgs.length || img_elem.nodeName.toLowerCase() != "img") {
        console.error("debug here");
        return;
    }
    img_elem.setAttribute("src", dir + imgs[where]);
    let next: number = where + 1;
    if(where == imgs.length - 1) next = 0;
    window.setTimeout(img_roll, interval, img_elem, dir, imgs, next, interval);
} //}

// div>img
export function img_roll_inject_css(div__: HTMLElement, dir: string, imgs: string[], where: number, interval: number): void //{
{
    if(utils.isHidden(div__)) return;
    if(where >= imgs.length       || div__.nodeName.toLowerCase() != "div" ||
       div__.children.length > 2  || div__.firstChild.nodeName.toLowerCase() != "img" ||
      (div__.children.length == 2 && div__. lastChild.nodeName.toLowerCase() != "style")) {
        console.error("debug here");
        return;
    }
    let __img: HTMLElement = div__.firstChild as HTMLElement;
    let is_first: boolean = false;
    if(div__.children.length == 2)
        div__.removeChild(div__.lastChild);
    else
        is_first = true;
    let id = utils.makeid(16);
    if(!dir.endsWith("/")) dir = dir + "/";
    let css_template: string; 
    let current_img:  string = dir + imgs[where];
    let origin_img:   string;
    let dtime: number = interval * 0.2;
    if(where == 0) {
        origin_img = dir + imgs[imgs.length - 1];
    } else {
        origin_img = dir + imgs[where - 1];
    }
    if (is_first) {
        css_template = 
        `<style>
        #${id} {
            background-image: url(${current_img});
        }
        </style>`;
    } else  {
        css_template = 
        `<style>
        #${id} {
            background-image: url(${current_img});
            animation-name:   anim-${id};
            animation-duration: ${dtime / 1000.0}s;
            background-size: cover;
            background-repeat: no-repeat;
        }
        @keyframes anim-${id} {
            0%   {background-image: url(${origin_img}); } 
            100% {background-image: url(${current_img});}
        }
        </style>`;
    }
    let cssnode = utils.createNodeFromHtmlString(css_template);
    div__.appendChild(cssnode);
    __img.setAttribute("src", current_img);
    __img.style.visibility = "hidden";
    div__.setAttribute("id", id);
    let next: number = where + 1;
    if(where == imgs.length - 1) next = 0;
    window.setTimeout(img_roll_inject_css, interval, div__, dir, imgs, next, interval);
} //}
// img
export function img_roll_inject_css_helper_img(img_elem: HTMLElement, dir: string, imgs: string[], where: number, interval: number): void //{
{
    img_roll_inject_css(img_elem.parentNode as HTMLElement, dir, imgs, where, interval);
} //}
