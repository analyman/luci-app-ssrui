/// <reference path="../www/luci-static/resources/ssrui/fucking.js"/>

import {SSRServer, SSRSubscription, default_local_address, default_local_port} from './subscribe';
import {_EventTarget, UActiveChange, UContentChange, UServerListChange} from './event';
import * as utils from './utils';
import * as fucking from '../www/luci-static/resources/ssrui/fucking';
import * as CONS from './constants';

// export constants to global scope
window["CONS"] = {};
for(let i in CONS)
    window["CONS"][i] = CONS[i];

// these infomation of image should be generated by lua in html, in other words should be 
// accessable in global scope
let img_dir = (window as any).img_dir;
let imgs    = (window as any).roll_imgs;
if (imgs == null || imgs.length == 0) {
    img_dir = "/luci-static/resources/ssrui/img/";
    imgs    = ["cat.jpg"];
}

// used for adding new subscription and when change of servers occurs
function subscribe_list_content(list: any[]) //{
{
    let out: any[] = [];
    list.map(x => out.push([x.group, x.server_list[0].group]));
    update_list_group(fucking.ElementsAccessor.subscriptions_group, out.map(x => x[1]), ["list-group-item"], "subscription", true, CONS.NewButtonName);
    for(let i = 0; i<fucking.ElementsAccessor.subscriptions_group.children.length - 1; i++)
        (fucking.ElementsAccessor.subscriptions_group.children[i] as any).ex_info = out[i][0] || "unknow address";
    (fucking.ElementsAccessor.subscriptions_group.lastChild as any).ex_info = CONS.AddNewSubs;
    fucking.ElementsAccessor.links_group.dispatchEvent(new CustomEvent(UContentChange));
} //}
// add new subscription
function add_new_subscription(url) //{
{
    let list: any[] = fucking.classify_servers_by_subscription(fucking.VarAccessor.server_index);
    list.push({group: url, server_list: [{group: "NEW DEFINED SUBSCRIPTION"}]});
    subscribe_list_content(list);
} //}

document.addEventListener("DOMContentLoaded", function() {
    fucking.retry_get_elements();

    fucking.ElementsAccessor.subscriptions_group.addEventListener(UContentChange, function() {
        let list: any[] = fucking.classify_servers_by_subscription(fucking.VarAccessor.server_index);
        subscribe_list_content(list);
    });

    document.addEventListener(UServerListChange, function() {
        let list: any[] = fucking.classify_servers_by_subscription(fucking.VarAccessor.server_index);
        subscribe_list_content(list);
        fucking.ElementsAccessor.subscriptions_group.dispatchEvent(new CustomEvent(UContentChange));
    });

    // mouse hover behavior
    fucking.ElementsAccessor.subscriptions_group.addEventListener("mouseover", function(earg: MouseEvent) {
        earg.stopPropagation();
        let origin_li: HTMLElement = earg.target as HTMLElement;
        if(origin_li.nodeName.toLowerCase() != "li") origin_li = (origin_li as HTMLElement).parentNode as HTMLElement;
        if(origin_li.nodeName.toLowerCase() != "li") return;
        let width:  number = origin_li.offsetWidth * 0.7;
        let height: number = origin_li.offsetHeight;
        let insert_tip: HTMLElement = utils.createNodeFromHtmlString(`<div class='rounded bg-white border border-warning m-2 p-2 position-absolute' style="z-index: 3; width: ${width}px;">` 
            + (origin_li as any).ex_info + "</div>");
        height += (insert_tip as HTMLElement).offsetHeight;
        insert_tip.style.bottom = (height * 1.05).toString();
        origin_li.appendChild(insert_tip);
        return;
    });
    fucking.ElementsAccessor.subscriptions_group.addEventListener("mouseout", function(earg: MouseEvent) {
        earg.stopPropagation();
        let origin_li: Element = earg.target as Element;
        if(origin_li.nodeName.toLowerCase() != "li") origin_li = (origin_li as Element).parentNode as Element;
        if(origin_li.nodeName.toLowerCase() != "li") return;
        origin_li.removeChild(origin_li.lastChild);
        return;
    });

    fucking.ElementsAccessor.links_group.addEventListener(UContentChange, function() {
        let [active_elem, c_len, i]: [HTMLElement, number, number] = list_get_active_elem(fucking.ElementsAccessor.subscriptions_group);
        if (i == c_len - 1) {
            while(fucking.ElementsAccessor.links_group.firstChild)
                fucking.ElementsAccessor.links_group.removeChild(fucking.ElementsAccessor.links_group.firstChild);
            let BG_IMG: HTMLElement = utils.createNodeFromHtmlString(`<li class="list-group-item hello"><div class="rounded"><img class="mw-100 mh-100 h-auto"></div></li>`);
            fucking.ElementsAccessor.links_group.appendChild(BG_IMG);
            img_roll_inject_css(BG_IMG.firstChild as HTMLElement, img_dir, imgs, 0, 3 * 1000);
            return;
        }
        let link: string = (active_elem as any).ex_info;
        let list: any[] = fucking.classify_servers_by_subscription(fucking.VarAccessor.server_index);
        let server_list: any[] = null;
        for(let j = 0; j<list.length; j++) {
            if(link == list[j].group){
                server_list = list[j].server_list;
                break;
            }
        }
        if(server_list == null) {
            while(fucking.ElementsAccessor.links_group.firstChild)
                fucking.ElementsAccessor.links_group.removeChild(fucking.ElementsAccessor.links_group.firstChild);
            return;
        }
        let out: any[] = [];
        server_list.map(x => out.push(x.remarks || "UNKONW"));
        update_list_group(fucking.ElementsAccessor.links_group, out, ["list-group-item"], "link", false);
        // little info table about this server;
        let info: any[] = [];
        server_list.map( x => {
            let table_template = `
            <div><table class="table table-light rounded mt-2 border">
                <tr><td>${CONS.Server} :</td>           <td>${x.server}       </td></tr>
                <tr><td>${CONS.Server_Port}:</td>       <td>${x.server_port}  </td></tr>
                <tr><td>${CONS.Local_Address}:</td>     <td>${x.local_address}</td></tr>
                <tr><td>${CONS.Local_Port}:</td>        <td>${x.local_port}   </td></tr>
                <tr><td>${CONS.Password}:</td>          <td>${x.password}     </td></tr>
                <tr><td>${CONS.Method}:</td>            <td>${x.method}       </td></tr>
                <tr><td>${CONS.Protocol}:</td>          <td>${x.protocol}     </td></tr>
                <tr><td>${CONS.Protocol_Parameter}:</td><td>${x.protoparam}   </td></tr>
                <tr><td>${CONS.Obfs}:</td>              <td>${x.obfs}         </td></tr>
                <tr><td>${CONS.Obfs_Parameter}:</td>    <td>${x.obfsparam}    </td></tr>
            </table></div>`
            info.push(utils.createNodeFromHtmlString(table_template));
        });
        for(let i = 0; i<fucking.ElementsAccessor.links_group.children.length; i++)
            fucking.ElementsAccessor.links_group.children[i].appendChild(info[i]);
    });

    // LIST CLICK Events
    fucking.ElementsAccessor.links_group.addEventListener("click", (ev: MouseEvent) => {
        list_click_change_active(ev);
    });
    fucking.ElementsAccessor.subscriptions_group.addEventListener("click", (ev: MouseEvent) => {
        if((ev.target as HTMLElement).innerText == CONS.NewButtonName)
            address_bar.show();
        let result = list_click_change_active(ev);
        if (result) 
            fucking.ElementsAccessor.links_group.dispatchEvent(new CustomEvent(UContentChange));
    });
});

// (ul | or) > li > a.active
export function list_click_change_active(eargs: Event): boolean //{
{
    let origin_target: Element  = eargs.target as Element;
    let current_target: Element = eargs.currentTarget as Element;
    if (!current_target.nodeName.toLowerCase().match(/(ul)|(ol)/)) return false;
    if (origin_target.nodeName.toLowerCase() != "a") return false;
    if (origin_target.parentNode.nodeName.toLowerCase() != "li") return false;
    if (origin_target.parentNode.parentNode != current_target) return false;
    eargs.stopPropagation();
    if (origin_target.classList.contains("active")) return false;
    for(let i = 0; i<current_target.children.length; ++i) {
        current_target.children[i].children[0].classList.remove("active");
    }
    origin_target.classList.add("active");
    return true;
} //}
export function list_get_active_elem(list: HTMLElement): [HTMLElement, number, number] //{
{
    let i: number;
    let c_len = list.children.length;
    for(i = 0; i<c_len; i++)
        if((list.children[i].firstChild as HTMLElement).classList.contains("active"))
            break;
    let active_elem: HTMLElement = list.children[i] as HTMLElement;
    return [active_elem, c_len, i];
} //}

export function get_active_elem(ulol: HTMLElement): HTMLElement //{
{
    if (!ulol.nodeName.toLowerCase().match(/(ul)|(ol)/)) return null;
    for(let i = 0; i<ulol.children.length; i++) {
        let tt: HTMLElement = ulol.children[i].firstChild as HTMLElement;
        if(tt.classList.contains("active"))
            return tt;
    }
    return null;
} //}

export function update_list_group(
    list: Element, msgs: string[], extra_classes: string[], href_and_id_prefix: string,
    new_button: boolean = false, new_button_str: string = "NEW"): void //{
{
    if (!list.nodeName.toLowerCase().match(/(ol)|(ul)/)) return;
    let k: number = 0;
    for(let j = 0; j<list.children.length; ++j) {
        if (list.children[j].nodeName.toLowerCase() != "li")
            continue;
        if (list.children[j].children[0].classList.contains("active"))
            break;
        ++k;
    }
    while(list.lastChild)
        list.removeChild(list.lastChild);
    if (msgs.length == 0 && !new_button) return;
    let new_node_li = document.createElement("li");
    let new_node    = document.createElement("a");
    new_node_li.appendChild(new_node);
    for(let i = 0; i<msgs.length; ++i) {
        let nn: Element = new_node_li.cloneNode(true) as Element;
        nn.children[0].setAttribute("href", "#" + href_and_id_prefix + (i + 1));
        nn.children[0].setAttribute("id",   href_and_id_prefix + "-" + (i + 1));
        nn.children[0].innerHTML = msgs[i];
        extra_classes.map(cls => nn.children[0].classList.add(cls));
        list.appendChild(nn);
    }
    if (new_button) {
        new_node.setAttribute("href", "#" + href_and_id_prefix + "0");
        new_node.setAttribute("id",   href_and_id_prefix + "-" + "0");
        new_node.innerHTML = new_button_str;
        extra_classes.map(cls => new_node.classList.add(cls));
        list.appendChild(new_node_li);
    }
    if (list.children.length <= k)
        (list.lastChild.firstChild as Element).classList.add("active");
    else
        list.children[k].children[0].classList.add("active");
    return;
} //}

export function img_roll(img_elem: HTMLElement, dir: string, imgs: string[], where: number, interval: number): void //{
{
    if(utils.isHidden(img_elem)) return;
    if(where >= imgs.length || img_elem.nodeName.toLowerCase() != "img") {
        console.error("debug here");
        return;
    }
    img_elem.setAttribute("src", dir + imgs[where]);
    let next: number = where + 1;
    if(where == imgs.length - 1) next = 0;
    window.setTimeout(img_roll, interval, img_elem, dir, imgs, next, interval);
} //}

// div>img
export function img_roll_inject_css(div__: HTMLElement, dir: string, imgs: string[], where: number, interval: number): void //{
{
    if(utils.isHidden(div__)) return;
    if(where >= imgs.length       || div__.nodeName.toLowerCase() != "div" ||
       div__.children.length > 2  || div__.firstChild.nodeName.toLowerCase() != "img" ||
      (div__.children.length == 2 && div__. lastChild.nodeName.toLowerCase() != "style")) {
        console.error("debug here");
        return;
    }
    let __img: HTMLElement = div__.firstChild as HTMLElement;
    let is_first: boolean = false;
    if(div__.children.length == 2)
        div__.removeChild(div__.lastChild);
    else
        is_first = true;
    let id = utils.makeid(16);
    if(!dir.endsWith("/")) dir = dir + "/";
    let css_template: string; 
    let current_img:  string = dir + imgs[where];
    let origin_img:   string;
    let dtime: number = interval * 0.2;
    if(where == 0) {
        origin_img = dir + imgs[imgs.length - 1];
    } else {
        origin_img = dir + imgs[where - 1];
    }
    if (is_first) {
        css_template = 
        `<style>
        #${id} {
            background-image: url(${current_img});
        }
        </style>`;
    } else  {
        css_template = 
        `<style>
        #${id} {
            background-image: url(${current_img});
            animation-name:   anim-${id};
            animation-duration: ${dtime / 1000.0}s;
            background-size: cover;
            background-repeat: no-repeat;
        }
        @keyframes anim-${id} {
            0%   {background-image: url(${origin_img}); } 
            100% {background-image: url(${current_img});}
        }
        </style>`;
    }
    let cssnode = utils.createNodeFromHtmlString(css_template);
    div__.appendChild(cssnode);
    __img.setAttribute("src", current_img);
    __img.style.visibility = "hidden";
    div__.setAttribute("id", id);
    let next: number = where + 1;
    if(where == imgs.length - 1) next = 0;
    window.setTimeout(img_roll_inject_css, interval, div__, dir, imgs, next, interval);
} //}
// img
export function img_roll_inject_css_helper_img(img_elem: HTMLElement, dir: string, imgs: string[], where: number, interval: number): void //{
{
    img_roll_inject_css(img_elem.parentNode as HTMLElement, dir, imgs, where, interval);
} //}

// initial state should be hidden with 'd-none' bootstrap class
class MessageBar extends _EventTarget //{
{
    where: HTMLElement = null;
    displayState: boolean   = false;
    displayClass: string;
    msgQueue: any[][];
    amountOfTimeOfInvoking: number;
    constructor(target: HTMLElement, displayClass: string = "d-block") {
        super();
        if(target == null) {
            console.error("null target");
            return;
        }
        this.where                  = target;
        this.displayClass           = displayClass;
        this.msgQueue               = [];
        this.amountOfTimeOfInvoking = 0;
    }
    _show(): void {
        if(this.displayState) return;
        this.where.classList.remove("d-none"); 
        this.where.classList.add(this.displayClass);
        this.displayState = true;
    }
    _hide(): void {
        if(!this.displayState) return;
        this.where.classList.remove(this.displayClass);
        this.where.classList.add("d-none"); 
        this.displayState = false;
    }
    __run(): void {
        if(this.displayState == true) return;
        if(this.msgQueue.length == 0) return;
        let keep = this.amountOfTimeOfInvoking;
        this.amountOfTimeOfInvoking++;
        let i: any[] = this.msgQueue.splice(0, 1)[0];
        if(i.length == 2) {
            this.where.innerHTML = i[0];
            this._show();
            window.setTimeout(function(obj: MessageBar) {
                if(obj.amountOfTimeOfInvoking != ++keep) // this message had been cancelled
                    return;
                obj._hide();
                obj.__run();
            }, i[1], this);
        } else if (i.length == 3) {
            this.where.innerHTML = i[0];
            this._show();
            let etarget: _EventTarget = i[1];
            let event: string = i[2];
            etarget.addEventListener(event, (earg) => {
                if(this.amountOfTimeOfInvoking != ++keep) // this message had been cancelled
                    return;
                this._hide();
                this.__run();
            }, {once: true});
        } else {
            console.error("unexpected length.");
            return;
        }
    }
    ShowWithDuration(html_msg: string, duration: number, force: boolean = false): void {
        this.msgQueue.push([html_msg, duration]);
        if(force) {
            this.displayState = false;
        }
        this.__run();
    }
    ShowWithEvent(html_msg: string, target: _EventTarget, eventType: string, force: boolean = false): void {
        this.msgQueue.push([html_msg, target, eventType]);
        if(force) {
            this.displayState = false;
        }
        this.__run();
    }
} //}

class AddressBar //{
{
    where: HTMLTextAreaElement = null;
    displayState: boolean   = false;
    displayClass: string;
    constructor(target: HTMLTextAreaElement, displayClass: string = "d-block") {
        if(target == null) {
            console.error("null target");
            return;
        }
        this.where                  = target;
        this.displayClass           = displayClass;
    }
    show(): void {
        if(this.displayState) return;
        this.where.classList.remove("d-none"); 
        this.where.classList.add(this.displayClass);
        this.displayState = true;
    }
    hide(): void {
        if(!this.displayState) return;
        this.where.classList.remove(this.displayClass);
        this.where.classList.add("d-none"); 
        this.displayState = false;
    }
    validate(): boolean {
        return SSRSubscription.url_pattern.test(this.where.value);
    }
    just_one_line(): void {
        this.where.value = this.where.value.replace(/\r|\n/, "");
    }
    get_url(): string {
        return this.where.value;
    }
    clean_input(): void {
        this.where.value = "";
    }
} //}

var address_bar: AddressBar;
var message_bar: MessageBar;

document.addEventListener("DOMContentLoaded", function() {
address_bar = new AddressBar(fucking.ElementsAccessor.address_bar);
message_bar = new MessageBar(fucking.ElementsAccessor.update_info);

message_bar.addEventListener("complete", function() {
    message_bar._hide();
});
message_bar.addEventListener("beginUpdate", function(earg: CustomEvent){
    message_bar.ShowWithDuration(`<div>${CONS.BeginUpdate}</div>`, 1000 * 1.5);
    return;
});

fucking.ElementsAccessor.address_bar.addEventListener("input", function() {address_bar.just_one_line();});
fucking.ElementsAccessor.address_bar.addEventListener("keydown", function(earg: KeyboardEvent) {
    if(earg.key.toLowerCase() != "enter") return;
    if(!address_bar.validate()) {
        message_bar.ShowWithDuration(
            `<div class="bg-danger rounded m-2 p-2">${CONS.URL_ERROR}</div>`, 3.9 * 1000);
        return
    }
    add_new_subscription(address_bar.get_url());
    address_bar.clean_input();
    address_bar.hide();
    message_bar.ShowWithDuration(
        `<div class="bg-success rounded m-2 p-2">${CONS.UPDATEIT}</div>`, 3.9 * 1000);
});

var in_updating = false;
fucking.ElementsAccessor.subs_update_button.addEventListener("click", () => {
    if(in_updating) return; // MAYBE SOME MESSAGE TO HINT USER
    message_bar.dispatchEvent(new CustomEvent("beginUpdate", {detail: {args: [3 * 1000]}}));
    let active_elem: HTMLElement = get_active_elem(fucking.ElementsAccessor.subscriptions_group);
    if(active_elem == null) {
        console.error("impossible");
        return;
    }
    let url = (active_elem.parentNode as any).ex_info;
    if((fucking.ElementsAccessor.subscriptions_group.lastChild as Element) == (active_elem.parentNode as Element)) {
        message_bar.ShowWithDuration(`<div class="bg-warning">${CONS.GIVEMEADDR}</div>`, 2 * 1000, true);
        return;
    }
    let sss: SSRSubscription;
    try {
        sss = new SSRSubscription(url);
    } catch {
        message_bar.ShowWithDuration(`<div class="bg-warning">${CONS.DONTTRYIT}</div>`, 2 * 1000, true);
        return;
    }
    in_updating = true;
    let fi: Promise<boolean> = sss.Subscribe();
    fi.then(() => {
        let new_ssr = sss.toRecord();
        let nn = fucking.servers_json_to_list([new_ssr as any]);
        // delete obsolete servers
        let dd = fucking.VarAccessor.server_index.filter(x => x["subs_link"] != sss.URL);
        let old_remarks = dd.map(x => x["remarks"]).filter(x => x != null);
        nn.map( x => {
            if(old_remarks.indexOf(x["remarks"]) != -1)
                return;
            dd.push(x);
        });
        fucking.VarAccessor.server_index = dd;
        document.dispatchEvent(new CustomEvent(UServerListChange, {detail: "update"}));
        in_updating = false;
        return;
    }, () => {
        message_bar.ShowWithDuration(`<div class="bg-warning">${CONS.SUBSFAIL}</div>`, 2 * 1000, true);
        in_updating = false;
        return;
    });
    return;
});

fucking.ElementsAccessor.subs_new_button.addEventListener("click", function() {
    address_bar.show();
});

fucking.ElementsAccessor.subs_delete_button.addEventListener("click", function() {
    let [elem, len, pos] = list_get_active_elem(fucking.ElementsAccessor.subscriptions_group);
    if(pos == len - 1) {
        message_bar.ShowWithDuration(`<div class="bg-warn rounded">${CONS.DONTTRYIT}</div>"`, 2.2 * 1000);
        return;
    }
    let url = (elem as any).ex_info;
    let old_ = fucking.classify_servers_by_subscription(fucking.VarAccessor.server_index);
    let new_ = [];
    for(let i in old_) {
        if(old_[i]["group"] == url)
            continue;
        new_.push(old_[i]);
    }
    fucking.VarAccessor.server_index = fucking.servers_json_to_list(new_);
    document.dispatchEvent(new CustomEvent(UServerListChange, {detail: "update"}));
});

}); // document.addEventListener()
